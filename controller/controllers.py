import pygame
from pygame.constants import QUIT, KEYDOWN, K_ESCAPE, MOUSEBUTTONDOWN, MOUSEBUTTONUP

from events.events import TickEvent, SwapGemsRequest, QuitEvent


class NaiveAIControllerV1:
    """
    NaiveAIControllerV1 looks at the gem grid (board) and
    determines the valid moves with move_finder.

    move_finder returns a randomly chosen move
    which is sent to the model as a SwapGemsRequest.
    """

    def __init__(self, event_manager, board, move_finder):
        self.event_manager = event_manager
        self.event_manager.register_listener(self)
        self.game = board
        self.move_finder = move_finder

        # ----------------------------------------------------------------------

    def notify(self, event):
        if isinstance(event, TickEvent):
            ev = None
            if self.game.game_state == "waiting_for_input":
                # find move and select
                swap_locations = self.move_finder(self.game.gem_grid.grid)
                ev = SwapGemsRequest(swap_locations)

            if ev is not None:
                self.event_manager.post(ev)


class MonteCarloController:
    """
    To do
    """

    def __init__(self, event_manager, monte_carlo_move_finder, state_parser, board):
        self.event_manager = event_manager
        self.event_manager.register_listener(self)
        # self.board = board_simulator
        self.move_finder = monte_carlo_move_finder
        self.state_parser = state_parser
        self.board = board

        # ----------------------------------------------------------------------

    def notify(self, event):
        if isinstance(event, TickEvent):
            ev = None
            if self.board.game_state == "waiting_for_input":
                # if state param not empty get state from event
                # raw_state = event.state
                # if raw_state:
                #     print(raw_state)
                # parse state

                # raw_state = self.board.get_game_state()
                # current_state = self.state_parser.parse_state(raw_state)
                current_state = self.board.get_game_state_tuple()

                # instantiate monte carlo object and update to current state
                mc = self.move_finder
                mc.update(current_state)

                # pick move from mcts
                move = mc.pick_move()

                # create swap gems reqest
                ev = SwapGemsRequest(move)

            if ev is not None:
                self.event_manager.post(ev)


class MouseController:
    """
    MouseController takes Pygame event_files generated by the
    mouse and uses them to control the model, by sending Requests
    or to control the Pygame display directly, as with the QuitEvent
    """

    def __init__(self, event_manager):
        self.event_manager = event_manager
        self.event_manager.register_listener(self)
        self.is_second_click = False
        self.first_row = -1
        self.first_column = -1

    # ----------------------------------------------------------------------
    def notify(self, event):
        if isinstance(event, TickEvent):
            # Handle Input Events
            for event in pygame.event.get():
                ev = None
                if event.type == QUIT:
                    ev = QuitEvent()
                elif event.type == KEYDOWN and event.key == K_ESCAPE:
                    ev = QuitEvent()
                elif event.type == MOUSEBUTTONDOWN and not self.is_second_click:
                    # First click, save coordinates
                    x = event.pos[0]
                    y = event.pos[1]
                    row, column = self.event_manager.gui_vars.pixel_to_grid(y, x)

                    if row == -1 or column == -1:
                        # clicked not on grid
                        self.is_second_click = False
                    else:
                        # clicked on grid
                        self.first_row = row
                        self.first_column = column
                        self.is_second_click = True

                elif event.type == MOUSEBUTTONUP and self.is_second_click:
                    # Second click, create event object to send
                    x = event.pos[0]
                    y = event.pos[1]
                    row, column = self.event_manager.gui_vars.pixel_to_grid(y, x)
                    if row == -1 or column == -1:
                        # clicked not on grid
                        self.is_second_click = False
                    else:
                        # clicked on grid
                        swap_locations = [(self.first_row, self.first_column), (row, column)]
                        ev = SwapGemsRequest(swap_locations)
                        self.is_second_click = False

                if ev is not None:
                    self.event_manager.post(ev)


class CPUSpinnerController:
    """..."""

    def __init__(self, event_manager):
        self.event_manager = event_manager
        self.event_manager.register_listener(self)

        self.keepGoing = 1

    # ----------------------------------------------------------------------
    def run(self):
        while self.keepGoing:
            event = TickEvent()
            self.event_manager.post(event)

    # ----------------------------------------------------------------------
    def notify(self, event):
        if isinstance(event, QuitEvent):
            # this will stop the while loop from running
            self.keepGoing = False
